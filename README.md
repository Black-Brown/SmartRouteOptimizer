
# SmartRouteOptimizer

Optimizaci√≥n paralela de rutas de **√∫ltima milla (Last-Mile)** con **C#/.NET 8**, **TPL** y **API REST**.
Ejecuta m√∫ltiples heur√≠sticas (Greedy / Gen√©tico, etc.) **en paralelo**, comparte estado de manera **thread-safe**, reporta **m√©tricas en tiempo real** y devuelve rutas para visualizaci√≥n (p. ej. con **Leaflet**).

> ‚ú® Ideal para escenarios tipo Amazon, UberEats, FedEx: m√∫ltiples pedidos dispersos, ventanas de tiempo, capacidad de veh√≠culos, congesti√≥n y rutas variantes.

---

## Caracter√≠sticas

* ‚ö° **Ejecuci√≥n en paralelo** con Task Parallel Library (TPL): varias heur√≠sticas en simult√°neo.
* üîÅ **Orquestador de tareas** con `Task.WhenAll()` y cancelaci√≥n por tiempo (`CancellationToken`).
* üîí **Estado compartido thread-safe** (locks) para progreso, evaluaciones y resultados.
* üìä **M√©tricas en tiempo real**: evaluaciones, progreso %, tiempo, costo por algoritmo, costo por entrega.
* üåç **Rutas listas para el mapa** (coordenadas) y colores por veh√≠culo.
* üå± **Escalable**: a√±ade m√°s tareas/heur√≠sticas o divide por zonas geogr√°ficas.

---

## Arquitectura

* **Frontend Layer**: UI HTML5, mapa con Leaflet, monitores de progreso y resultados.
* **API Layer**: `OptimizerController` con endpoints `POST /start`, `GET /status/{id}`, `GET /result/{id}`.
* **Service Layer**: `OptimizationEngine` (motor), `Session Manager` y sesiones en memoria (`ConcurrentDictionary`).
* **Parallel Execution Layer**: orquestaci√≥n con **Tasks** para Greedy/Gen√©tico + tarea de progreso.
* **Synchronization Layer**: `lock` para listas compartidas, `CancellationToken` y `Task.WhenAll()`.

---

## Estructura del proyecto

> Sugerencia de layout (aj√∫stalo a tu repo actual):

```
SmartRouteOptimizer/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ SmartRouteOptimizer.Api/
‚îÇ       ‚îú‚îÄ‚îÄ SmartRouteOptimizer.Api.csproj
‚îÇ       ‚îú‚îÄ‚îÄ Program.cs
‚îÇ       ‚îú‚îÄ‚îÄ Controllers/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ OptimizerController.cs
‚îÇ       ‚îú‚îÄ‚îÄ Models/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ OptimizationRequest.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ClientDto.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ VehicleDto.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ AlgorithmStatusDto.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ProgressDto.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ AlgorithmResultDto.cs
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ RouteDto.cs
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ SolutionDto.cs
‚îÇ       ‚îî‚îÄ‚îÄ Services/
‚îÇ           ‚îú‚îÄ‚îÄ OptimizationSession.cs
‚îÇ           ‚îî‚îÄ‚îÄ OptimizationEngine.cs
‚îî‚îÄ‚îÄ README.md
```

---

## Levantamiento r√°pido

```bash
# 1) Entrar al proyecto API
cd src/SmartRouteOptimizer.Api

# 2) Restaurar y ejecutar (requiere .NET 8)
dotnet restore
dotnet run

# 3) Swagger (dev)
# http(s)://localhost:5xxx/swagger
```

**CORS** est√° habilitado para pruebas locales. Restringe or√≠genes en producci√≥n.

---

## API Reference

### POST `/api/optimizer/start`

Inicia una optimizaci√≥n y devuelve `sessionId`.

**Body (JSON)**

```json
{
  "clients": [
    { "id": 1, "lat": 18.49, "lng": -69.93, "prioridad": 1, "ventanaInicio": 0, "ventanaFin": 3600, "nombre": "Cliente A" }
  ],
  "vehicles": [
    { "id": 101, "capacidad": 25, "color": "#1f77b4" }
  ],
  "timeLimitSeconds": 20
}
```

**200 OK**

```json
{ "sessionId": "6e4f8d7a-..." }
```

---

### GET `/api/optimizer/status/{sessionId}`

Devuelve **progreso en tiempo real**.

**200 OK**

```json
{
  "sessionId": "6e4f8d7a-...",
  "evaluaciones": 12500,
  "elapsedSeconds": 5.4,
  "progressPercent": 62.3,
  "algorithms": [
    { "name": "Greedy-1", "state": "Running", "cost": null, "lastUpdate": "2025-08-22T19:10:34.123Z" }
  ],
  "message": "Explorando 62% del espacio de soluciones..."
}
```

---

### GET `/api/optimizer/result/{sessionId}`

Devuelve **resultado final**.

**200 OK**

```json
{
  "sessionId": "6e4f8d7a-...",
  "results": [
    { "algorithm": "Greedy-1", "cost": 96.2, "distanceKm": 145.1, "timeSeconds": 2.0 }
  ],
  "best": { "algorithm": "Greedy-1", "cost": 96.2, "distanceKm": 145.1, "timeSeconds": 2.0 },
  "bestEfficiencyPercent": 88.7,
  "costPerDelivery": 4.81,
  "routes": [
    {
      "vehicleId": 101,
      "vehicleColor": "#1f77b4",
      "coordinates": [[18.4861,-69.9312],[18.49,-69.93],[18.4861,-69.9312]],
      "deliveries": 5,
      "estimatedDistanceKm": 27.5
    }
  ]
}
```

**404**: a√∫n no finaliza.

---

## Modelo de datos

* **OptimizationRequest**

  * `clients: ClientDto[]`, `vehicles: VehicleDto[]`, `timeLimitSeconds: int`
* **ClientDto**: `id`, `lat`, `lng`, `prioridad`, `ventanaInicio`, `ventanaFin`, `nombre`
* **VehicleDto**: `id`, `capacidad`, `color`
* **ProgressDto**

  * `evaluaciones`, `elapsedSeconds`, `progressPercent`, `algorithms[]`, `message`
* **AlgorithmStatusDto**: `name`, `state` (`Waiting|Running|Completed`), `cost?`, `lastUpdate`
* **AlgorithmResultDto**: `algorithm`, `cost`, `distanceKm`, `timeSeconds`
* **SolutionDto**

  * `results[]`, `best`, `bestEfficiencyPercent`, `costPerDelivery`, `routes[]`
* **RouteDto**: `vehicleId`, `vehicleColor`, `coordinates [[lat,lng]]`, `deliveries`, `estimatedDistanceKm`

---

## M√©tricas y monitoreo

* ‚è±Ô∏è **Tiempo**: `elapsedSeconds`
* üßÆ **Trabajo computacional**: `evaluaciones`
* üìà **Progreso relativo**: `progressPercent`
* üí∏ **Costo** por algoritmo: `AlgorithmResultDto.cost`
* ü•á **Eficiencia**: `bestEfficiencyPercent`
* üßæ **Costo por entrega**: `costPerDelivery`
* üîé **Estados individuales**: `algorithms[]` (running/completed + lastUpdate)

> Estas m√©tricas permiten comparar heur√≠sticas, evaluar escalabilidad y analizar desempe√±o por sesi√≥n.

---

## Paralelizaci√≥n y sincronizaci√≥n

* **Estrategia principal**: paralelizaci√≥n **por heur√≠stica** (Greedy/Gen√©tico) + tarea de progreso.
* **Orquestaci√≥n**: `Task.Run(...)` para cada algoritmo y `Task.WhenAll(...)` para sincronizar la finalizaci√≥n.
* **L√≠mite de tiempo**: `CancellationTokenSource(TimeSpan.FromSeconds(...))`.
* **Estado compartido**: `OptimizationSession` con `lock` al modificar `Algorithms` (thread-safe).
* **Escalabilidad**: agrega m√°s tasks/algoritmos o divide por zonas/candidatos.

Ejemplo (resumen):

```csharp
var tasks = new List<Task<AlgorithmResultDto>>
{
    Task.Run(() => RunGreedy("Greedy-1", 2.0, session, rng, token), token),
    Task.Run(() => RunGenetic("Gen√©tico-1", 7.0, session, rng, token), token),
    // ...
};
var results = await Task.WhenAll(tasks);
```

Actualizaci√≥n segura:

```csharp
lock (session.Algorithms)
{
    var i = session.Algorithms.FindIndex(a => a.Name == name);
    if (i >= 0) session.Algorithms[i] = session.Algorithms[i] with
    {
        State = state,
        Cost = cost,
        LastUpdate = DateTimeOffset.UtcNow
    };
}
```

---

## Integraci√≥n con Frontend (Leaflet)

```js
// 1) Iniciar optimizaci√≥n
const start = await fetch('/api/optimizer/start', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ clients, vehicles, timeLimitSeconds: 20 })
});
const { sessionId } = await start.json();

// 2) Polling de progreso
const poll = setInterval(async () => {
  const r = await fetch(`/api/optimizer/status/${sessionId}`);
  if (!r.ok) return;
  const s = await r.json();
  // Actualiza UI: barra de progreso, evaluaciones, estados por algoritmo, etc.
}, 200);

// 3) Al finalizar ventana de tiempo, obtener resultado y dibujar rutas
setTimeout(async () => {
  clearInterval(poll);
  const rr = await fetch(`/api/optimizer/result/${sessionId}`);
  if (!rr.ok) return;
  const result = await rr.json();
  // Dibujar polylines con result.routes en Leaflet
}, 20000);
```

## Licencia

MIT (puedes cambiarla si tu proyecto lo requiere).

---

## Cr√©ditos

Proyecto acad√©mico/t√©cnico de **optimizaci√≥n de √∫ltima milla** con paralelizaci√≥n en .NET.
Nombre del proyecto: **SmartRouteOptimizer**.

